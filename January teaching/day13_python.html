<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta-name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duplicate Encoder – Daily Python Exercise</title>
    <link rel="stylesheet" href="day13_python.css">
</head>
<body>

<header>
    <h1>Daily Python Exercise</h1>
    <p class="subtitle">Topic: Duplicate Encoder Function</p>
</header>

<section class="content">

    <h2>Problem Description</h2>
    <p class="statement">
        The goal of this exercise is to transform a string into a new string where each character is replaced by:<br>
        <strong>"("</strong> if the character appears only once in the input string, or <strong>")"</strong> if it appears more than once.  
        This comparison must be case-insensitive.
    </p>

    <h3>Examples</h3>
    <ul>
        <li>"din" → "((("</li>
        <li>"recede" → "()()()"</li>
        <li>"Success" → ")())())"</li>
        <li>"(( @" → "))(("</li>
    </ul>

    <h2>My First Solution</h2>
    <div class="code-block">
<pre><code>def duplicate_encode(word):
    word = word.lower()
    result = ""
    for c in word:
        if word.count(c) > 1:
            result += ")"
        else:
            result += "("
    return result
</code></pre>
    </div>

    <h2>My Improved (Last) Solution</h2>
    <div class="code-block">
<pre><code>def duplicate_encode(word):
    word = word.lower()
    return "".join(["(" if word.count(c) == 1 else ")" for c in word])
</code></pre>
    </div>

    <h2>Detailed Explanation</h2>

    <p>
        This task is a classic example of character frequency transformation:  
        instead of returning counts or boolean checks, we encode each character based on how often it appears in the input string.  
        The key requirement is that the encoding must be <strong>case-insensitive</strong>, meaning characters such as 'S' and 's' should be treated as exactly the same.
        This forces us to normalize the entire string (usually to lowercase) before performing any counting or comparisons.  
        Without this normalization step, the encoding would be inconsistent and incorrect for mixed-case inputs like “Success”.
    </p>

    <p>
        In your <strong>first solution</strong>, you followed a clear and explicit procedural structure.  
        You converted the string to lowercase, initialized an empty result string, and then iterated through each character.  
        For each character, you called <code>word.count(c)</code> to determine how many times it appears in the normalized string.  
        If it occurred more than once, you appended a closing parenthesis <code>)</code>, otherwise you appended an opening parenthesis <code>(</code>.  
        This solution is correct, readable, and easy for beginners to understand. It expresses the logic clearly and step-by-step.
    </p>

    <p>
        However, this first approach does extra work internally.  
        For each character in the string, <code>word.count(c)</code> performs a full scan of the entire string.  
        Therefore, if the string length is <em>N</em>, the <code>count()</code> operation executes <em>N</em> times, making the algorithm’s time complexity
        approximately <strong>O(N²)</strong>.  
        For short strings this is perfectly acceptable, but for very large strings or performance-critical applications, it could become inefficient.
    </p>

    <p>
        My <strong>last solution</strong> is more compact, more expressive, and more aligned with common Python idioms.  
        The logic is identical, but it is expressed inside a list comprehension and joined together afterward.  
        The transformation <code>"(" if word.count(c)==1 else ")"</code> directly states the rule for encoding each character, 
        making the entire function visually cleaner.  
        Additionally, the use of <code>"".join()</code> avoids repeated string concatenations inside a loop, which is more efficient in Python.
    </p>

    <p>
        Nevertheless, the improved version still calls <code>word.count(c)</code> once for each character in the string,
        meaning the underlying time complexity remains O(N²).  
        But this is typical for most Codewars solutions for this specific kata, because the string length is generally small.
        In practice, if you wanted to further optimize it, you could precompute occurrences using a dictionary or the <code>collections.Counter</code> class,
        reducing the algorithm to linear time. But that would change the stylistic nature of the kata, and the compact one-liner approach is widely considered 
        the most elegant for this specific challenge.
    </p>

    <p>
        Overall, your progression from the first to the last solution demonstrates a strong understanding of how to refine Python code:  
        improving readability, compressing logic into expressive constructs, and eliminating unnecessary intermediate variables.  
        While both solutions produce identical output, the second one represents a more concise and Pythonic mindset — the kind of skill that 
        strengthens your overall fluency and prepares you for more complex transformations in future challenges.
    </p>

</section>

<footer>
    <p>Published for my daily coding subscribers. New problems every day.</p>
</footer>

</body>
</html>
