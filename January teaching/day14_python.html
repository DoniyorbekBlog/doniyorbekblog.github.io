<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alphabet Position – Daily Python Solutions</title>
    <link rel="stylesheet" href="day14_python.css">
</head>
<body>

    <header>
        <h1>Daily Python Challenge</h1>
        <h2>Kata: Replace Letters With Alphabet Positions</h2>
    </header>

    <section class="description">
        <h3>Description of the Problem</h3>
        <p>
            The objective of this kata is to transform a given string by converting every alphabetic 
            character into its corresponding position in the English alphabet. Alphabet indexing 
            starts at 1, which means:
        </p>
        <ul>
            <li>"a" → 1</li>
            <li>"b" → 2</li>
            <li>"c" → 3</li>
            <li>...</li>
            <li>"z" → 26</li>
        </ul>
        <p>
            Any character that is not a letter must be ignored completely (spaces, punctuation, digits, 
            symbols). After conversion, all numbers must be joined into one string separated with spaces.
        </p>

        <p><strong>Example Input:</strong>  
            "The sunset sets at twelve o' clock."
        </p>

        <p><strong>Example Output:</strong><br>
            20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11
        </p>

        <p>
            This transformation is extremely common in coding challenges because it tests your ability 
            to work with strings, ASCII codes, loops, and filtering. It also forces you to think about 
            clean and efficient ways to map characters to numeric values.
        </p>
    </section>

    <section class="solutions">
        <h3>My Solution</h3>
        <pre>
def alphabet_position(text):
    result = ""
    for letter in text.lower():
        if letter=="a":
            result += "1 "
        elif letter == 'b':
            result += "2 "
        elif letter == 'c':
            result += "3 "
        elif letter == 'd':
            result += "4 "
        elif letter == 'e':
            result += "5 "
        elif letter == 'f':
            result += "6 "
        elif letter == 'g':
            result += "7 "
        elif letter == "h":
            result += "8 "
        elif letter == 'i':
            result += "9 "
        elif letter == 'j':
            result += "10 "
        elif letter == 'k':
            result += "11 "
        elif letter == 'l':
            result += "12 "
        elif letter == 'm':
            result += "13 "
        elif letter == 'n':
            result += "14 "
        elif letter == 'o':
            result += "15 "
        elif letter == 'p':
            result += "16 "
        elif letter == 'q':
            result += "17 "
        elif letter == 'r':
            result += "18 "
        elif letter == 's':
            result += "19 "
        elif letter == 't':
            result += "20 "
        elif letter == 'u':
            result += "21 "
        elif letter == 'v':
            result += "22 "
        elif letter == 'w':
            result += "23 "
        elif letter == 'x':
            result += "24 "
        elif letter == 'y':
            result += "25 "
        elif letter == 'z':
            result += "26 "
    return result.strip()
        </pre>

        <h3>Best Solution</h3>
        <pre>
def alphabet_position(text):
    return ' '.join(str(ord(c) - 96) for c in text.lower() if c.isalpha())
        </pre>
    </section>

    <section class="explanation">
        <h3>Deep Explanation and Comparison</h3>
        <p>
            Both solutions achieve the same final output, but their levels of efficiency, elegance, and 
            scalability differ significantly. Your solution is very explicit: you manually map each letter 
            to its numeric position using a long chain of <code>if / elif</code> statements. This approach 
            works correctly, but it introduces a large amount of repetitive code. It also increases the 
            chance of human error and makes it harder to maintain.
        </p>
        <p>
            The best solution uses a far more efficient strategy. It leverages ASCII values through 
            <code>ord()</code>, which converts a character to its numeric code. Since lowercase letters 
            'a' through 'z' map to values 97–122 in ASCII, subtracting 96 converts them neatly to 1–26. 
            This eliminates the need for manual mapping and drastically reduces the amount of code. The 
            use of a generator inside <code>join()</code> means no extra lists or loops are needed, 
            further optimizing performance.
        </p>
        <p>
            Another strength of the best solution is its filtering using <code>isalpha()</code>, ensuring 
            non-letter characters are skipped automatically. This keeps the logic both robust and concise.
        </p>
        <p>
            Overall, the best solution is cleaner, more Pythonic, easier to maintain, and significantly 
            faster for large inputs. Your solution is functionally correct, but the best one is the type 
            of elegant, high-level implementation expected in advanced coding environments.
        </p>
    </section>

</body>
</html>
