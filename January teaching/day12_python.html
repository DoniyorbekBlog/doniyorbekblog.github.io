<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Duplicate Count – Daily Python Solution</title>
    <link rel="stylesheet" href="day12_python.css">
</head>
<body>

<header>
    <h1>Daily Python Challenge: Count the Number of Duplicates</h1>
    
</header>

<section class="problem">
    <h2>Problem: Count the Number of Duplicates</h2>
    <p class="statement">
        Write a function that returns the total number of **distinct** case-insensitive alphabetic characters and numeric digits 
        that appear **more than once** in the input string.  
        The string contains only letters (A–Z, a–z) and digits (0–9).
    </p>

    <p><strong>Examples</strong></p>
    <ul>
        <li>"abcde" → 0</li>
        <li>"aabbcde" → 2</li>
        <li>"aabBcde" → 2</li>
        <li>"indivisibility" → 1</li>
        <li>"Indivisibilities" → 2</li>
        <li>"aA11" → 2</li>
        <li>"ABBA" → 2</li>
    </ul>

    <h3>My Solution</h3>
    <pre><code>
def duplicate_count(text):
    text = text.lower()
    result = []
    for letter in text:
        if text.count(letter)>1:
            result.append(letter)
    return len(set(result))
    </code></pre>

    <h3>Best Solution</h3>
    <pre><code>
def duplicate_count(s):
    return len([c for c in set(s.lower()) if s.lower().count(c)>1])
    </code></pre>

    <h3>Detailed Explanation</h3>
    <p>
        The goal of this kata is not only to detect repeated characters but to count how many different characters repeat, regardless of how many times they repeat. 
        For example, if a character appears two times or ten times, it still counts as <strong>one</strong> duplicated character. 
        The main challenge in problems like this is to approach the solution in a clean, efficient, and logically structured manner that avoids unnecessary work.
    </p>

    <p>
        In My solution, the logic is straightforward and easy to understand. I begin by converting the string to lowercase so that case differences 
        (e.g., 'A' vs 'a') do not matter. Then I iterate through each character, count how many times it appears in the string, and if that count is greater 
        than one, I append it to a list. At the end, I convert the list to a set to remove duplicates, ensuring that each repeated character is counted only once. 
        This approach is completely correct, but it performs more computations than necessary because <code>text.count(letter)</code> runs for each character in the string. 
        So, in a string of length N, this results in an algorithm with a time complexity closer to O(N²). For typical short inputs this is acceptable, but for larger 
        inputs or optimized solutions it becomes less efficient.
    </p>

    <p>
        The best solution improves on this idea by eliminating unnecessary repeated counting and avoiding building an intermediate list of characters that may contain 
        duplicates. The key improvement is the use of <code>set(s.lower())</code>, which extracts only the unique characters from the string. This dramatically reduces 
        the number of times <code>count()</code> is executed because instead of counting occurrences for every character in the string, it counts them only for each unique 
        character. This immediately improves efficiency.
    </p>

    <p>
        Next, the best solution uses a list comprehension. Although this change may seem stylistic, it conveys a key improvement in readability and compactness. 
        By embedding the logic inside a single expression, the best solution clearly expresses the intent: 
        “Count how many unique characters occur more than once.”  
        This makes it easier to understand at a glance compared to having multiple steps with appending and converting to a set. 
    </p>

    <p>
        Lastly, another advantage of the best solution is that it avoids building a list that includes repeated characters before converting it to a set. 
        Because it iterates only over unique characters to begin with, the best solution is inherently more memory-efficient. 
        For large input strings, this can provide noticeable performance improvements. 
    </p>

    <p>
        Overall, both solutions are correct, but the best solution is more concise, more efficient, and more Pythonic. 
        It reduces unnecessary repeated work, expresses intent more clearly, and leverages Python's powerful built-in data structures 
        (like <code>set</code>) to streamline the logic. Understanding these differences helps build better habits toward writing 
        elegant, scalable code that is suitable for real-world problems as well as algorithmic challenges.
    </p>

</section>

<footer>
    <p>Posted for my daily coding subscribers. See you tomorrow.</p>
</footer>

</body>
</html>
